上一篇《Java线上解决方案1：JAVA热更新》我们讲解了JDK提供的Agent方式来实现代码不停服更新，
受限于JDK的Agent一些限制，这种方式无法实现以下功能：只能修改方法体，不能变更方法签名、不能增加和删除方法/类的成员属性。

对于Instrumentation和JVM的agent，网上有不少文章，大家可以自行参考，今天我们来了解下第二种热更方式：动态加载子类热更

# 核心思想

热更新，顾名思义就是要替换代码实现。根本需求就是我怎么把改好的class不停服替换进jvm中，并实现逻辑调用。

一种办法就是直接替换代码逻辑，上一篇agent方式就属于此方法。那如果我们想从代码层级上实现代码替换有哪些方式呢？
- 方法1：代理，例如spring的做法
- 方法2：子类覆盖

图片XXX

如上图，Parent类中有一个方法method1()，如果我们想改变里面逻辑，可以写一个Parent的子类SubClass，然后覆写方法method1()，
这样外部调用还是Parent，但实际调用的对象替换为SubClass，即可实现代码的替换。

# 优缺点对比

两者：都支持对特定逻辑进行热更

| 热更类型|优点|缺点|
| --- | --- | --- |
| Agent方式|对于JVM的类基本都可以热更 |只能修改方法体，不能变更方法签名、不能增加和删除方法/类的成员属性。<br />某些特定情况下，有极低机率导致JVM崩溃（可能是JVM的BUG，暂无法复现）|
| 动态编译新类| 因为采用的是新生成，所以支持修改签名，新增方法甚至新增实现等|需要把热更的逻辑按照注册机制编写，否则无法热更|

# 几个细节点

目前我们有了大概的思路，具体实现还有以下几个细节需要考虑：

- 如何生成子类？
- 生成的类如何加载进入jvm？
- 代码中如何调用才能实现调用的替换？

## 如何生成子类？

关于动态生成类的开源框架有几种：asm、cglib、javaassit，各有利弊，具体框架大家可以去网上自行搜索。

因为是热更新，所以对性能要求不高，但考虑到可读性和维护性，项目中尽量也不考虑直接操作字节码，所以最终我们选择了javaassist，它是可以直接通过java代码来构建新类。

假设我们已经把最新修改后的class上传到编译路径并覆盖了。那通过程序，我们可以读取该class的二进制字节，通过javaassist框架重新构建一个新类并进行如下几步操作：

- 改名，新类名为：原名+$$$SUBCLASS
- 让新类继承原类
- 设置子类的构造函数为public，且调用父类的默认构造函数，方便后续反射构建对象
- 忽略父类里的final方法，因为final是无法继承的，覆写会导致语法报错

## 生成的类如何加载进入jvm？
class想要加载进入jvm，唯一途径就是通过ClassLoader，因此这里我们自实现RecompileClassLoader继承于ClassLoader，实现二进制字节加载class进入jvm

## 对象注册机制？
现在我们已经有了一个新子类，它继承于原类，且覆写了原类的方法，那业务层怎么才能不修改代码的情况下能自动实现Parent替换为SubClass？

解决方案就是对象注册机制，简单理解就是对象的映射关系。
我们应用层用的都是从注册机制获取的，这样进行热更时，我们只要把当前注册的对象替换为新对象，因为新对象是原对象的子类，可覆写方法，从而实现逻辑的替换。

具体类图如下：


## 如何不停服新增功能？

有了上面的注册机制，那附带就有了一个新功能：动态新增注册类。比如新写一个注册类，调用注册系统接口可编译新类并注册进系统中，
尤其对于游戏服务，一般的逻辑都是走消息号映射逻辑的，天然适合注册机制，这样线上可动态新增消息号和对应的实现逻辑，从而达到不停服增加功能的目的。

# 总结
最终我们形成了这样的流程图：
流程图
